package com.xyz.strapp.domain.repository

import android.graphics.Bitmap
import android.util.Log
import com.xyz.strapp.data.dao.FaceImageDao
import com.xyz.strapp.domain.model.CheckInRequest
import com.xyz.strapp.domain.model.FaceImageEntity
import com.xyz.strapp.domain.model.UploadImageRequest
import com.xyz.strapp.endpoints.ApiService
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.ByteArrayOutputStream
import javax.inject.Inject
import javax.inject.Singleton

@Singleton // Repositories are often singletons managed by Hilt
class FaceLivenessRepository @Inject constructor(
    private val faceImageDao: FaceImageDao,
    private val apiService: ApiService,
    private val token: String?
) {

    /**
     * Converts a Bitmap to ByteArray, creates a FaceImageEntity,
     * and inserts it into the Room database via the DAO.
     *
     * @param bitmap The bitmap of the live face to save.
     * @param timestamp The time the image was captured, defaults to current time.
     * @return The row ID of the newly inserted face image, or null on failure.
     */
    suspend fun saveFaceImage(bitmap: Bitmap, timestamp: Long = System.currentTimeMillis()): Pair<Long, ByteArray>? {
        return withContext(Dispatchers.IO) { // Perform database and bitmap operations off the main thread
            try {
                val outputStream = ByteArrayOutputStream()
                bitmap.compress(
                    Bitmap.CompressFormat.JPEG,
                    90,
                    outputStream
                ) // Compress to JPEG, adjust quality as needed
                val imageByteArray = outputStream.toByteArray()

                if (imageByteArray.isEmpty()) {
                    Log.e("FaceLivenessRepository", "Converted ByteArray is empty.")
                    return@withContext null
                }

                val faceImageEntity = FaceImageEntity(
                    // id is typically auto-generated by Room, so 0 or null depending on your Entity
                    id = 0, // Or null if your primary key is nullable and auto-generated without default
                    imageData = imageByteArray,
                    timestamp = timestamp,
                    isUploaded = false // Initially, the image is not uploaded
                )

                val insertedId = faceImageDao.insertFaceImage(faceImageEntity)
                Log.d(
                    "FaceLivenessRepository",
                    "###@@@ Face image saved with ID: $insertedId, Size: ${imageByteArray.size} bytes"
                )
                Pair(insertedId, imageByteArray)
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "###@@@ Error saving face image", e)
                null // Return null or throw a custom domain exception
            }
        }
    }

    /**
     * Placeholder for fetching images that need to be uploaded.
     * This would typically fetch entities where isUploaded is false.
     */
    suspend fun getPendingUploads(): List<FaceImageEntity> {
        return withContext(Dispatchers.IO) {
            try {
                faceImageDao.getPendingUploads() // Assuming FaceImageDao has this method
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "###@@@ Error fetching pending uploads", e)
                emptyList()
            }
        }
    }

    /**
     * Placeholder for marking an image as uploaded.
     * This would update the isUploaded flag in the database.
     *
     * @param imageId The ID of the image that has been successfully uploaded.
     */
    suspend fun markImageAsUploaded(imageId: Long) {
        withContext(Dispatchers.IO) {
            try {
                faceImageDao.markAsUploaded(imageId) // Assuming FaceImageDao has this method
                Log.d("FaceLivenessRepository", "Image with ID $imageId marked as uploaded.")
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error marking image $imageId as uploaded", e)
            }
        }
    }

    /**
     * TODO: Implement the actual server upload logic.
     * This function would:
     * 1. Get pending images using getPendingUploads().
     * 2. For each image:
     *    a. Attempt to upload it using a Retrofit service (e.g., faceApiService).
     *    b. If upload is successful, call markImageAsUploaded().
     *    c. Handle errors, retries, etc.
     * This should ideally be managed by WorkManager for robust background execution.
     */
    suspend fun uploadPendingImagesToServer() {
        // Example structure:
        val pendingImages = getPendingUploads()
        if (pendingImages.isEmpty()) {
            Log.d("FaceLivenessRepository", "No pending images to upload.")
            return
        }
        Log.e(
            "FaceLivenessRepository",
            "###@@@ Pending upload image size : ${pendingImages.size}"
        )

        for (imageEntity in pendingImages) {
            try {
                val request = CheckInRequest(
                    latitude = 28.575447f,
                    longitude = 77.44539f,
                    dateTime = "Mon 8 Sep 2025 12:00 PM"
                )
                // 1. Create RequestBody from ByteArray for the image
                val imageRequestBody = imageEntity.imageData.toRequestBody(
                    "image/jpeg".toMediaTypeOrNull(), // Or "image/png" depending on your image format
                    0, // offset
                    imageEntity.imageData.size // size
                )
                // 2. Create MultipartBody.Part from the RequestBody
                // "file" is the part name expected by your server for the image file.
                // "image.jpg" is the filename that will be sent to the server.
                val imagePart = MultipartBody.Part.createFormData(
                    "file", // This is the 'name' of the part (form field name for the file)
                    "image_${imageEntity.id}.jpg", // This is the filename sent to the server
                    imageRequestBody
                )
                // 3. Create RequestBody for other data (from CheckInRequest)
                // You need to convert each field of your CheckInRequest to RequestBody
                // Assuming CheckInRequest has latitude, longitude, dateTime
                val latitudeRequestBody = 28.575447f.toString().toRequestBody("text/plain".toMediaTypeOrNull())
                val longitudeRequestBody = 77.44539f.toString().toRequestBody("text/plain".toMediaTypeOrNull())
                val dateTimeRequestBody = "Mon 8 Sep 2025 12:00 PM".toRequestBody("text/plain".toMediaTypeOrNull())

                // 4. Make the API call
                // Assuming your ApiService method is named 'uploadFaceImage' as defined above
                val imageRequest = UploadImageRequest("")
                val response = apiService.uploadImage(uploadData = imageRequest)
                delay(2000)
                if (response.isSuccessful) {
                    markImageAsUploaded(imageEntity.id)
                } else {
                    Log.e(
                        "FaceLivenessRepository",
                        "Failed to upload image ${imageEntity.id}: ${response.message()}"
                    )
                }
                Log.d("FaceLivenessRepository", "Simulating upload for image ID: ${imageEntity.id}")
                // Simulate success for now, actual implementation needed
                // markImageAsUploaded(imageEntity.id)

            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error uploading image ${imageEntity.id}", e)
            }
        }
        Log.d(
            "FaceLivenessRepository",
            "uploadPendingImagesToServer: Placeholder - implement actual upload logic."
        )
    }

    suspend fun startCheckIn(imageId: Long, imageByteArray: ByteArray) {

        try {

            if (imageByteArray.isEmpty()) {
                Log.e("FaceLivenessRepository", "Image byte array is empty! Cannot proceed with CheckIn.")
                // You should probably return or throw an error here instead of proceeding
                return
            }
            // 1. Create RequestBody from ByteArray for the image
            val imageRequestBody = imageByteArray.toRequestBody(
                "image/jpeg".toMediaTypeOrNull(), // Or "image/png" depending on your image format
                0, // offset
                imageByteArray.size // size
            )
            // 2. Create MultipartBody.Part from the RequestBody
            val imagePart = MultipartBody.Part.createFormData(
                "Image", // Name "Image" to match curl command
                "image_${imageId}.jpg", // This is the filename sent to the server
                imageRequestBody
            )

            val authToken = token ?: ""
            Log.d("FaceLivenessRepository", "###@@@ Auth Token for CheckIn: ${authToken}")

            val latitudeRequestBody = 28.575447f.toString().toRequestBody("text/plain".toMediaTypeOrNull())
            val longitudeRequestBody = 77.44539f.toString().toRequestBody("text/plain".toMediaTypeOrNull())
            val dateTimeRequestBody = "Mon 8 Sep 2025 12:00 PM".toRequestBody("text/plain".toMediaTypeOrNull())

            val request = CheckInRequest(
                latitude = 28.575447f,
                longitude = 77.44539f,
                dateTime = "Mon 8 Sep 2025 12:00 PM"
            )

            val partMap = mutableMapOf<String, RequestBody>()
            partMap["Latitude"] = latitudeRequestBody
            partMap["Longitude"] = longitudeRequestBody
            partMap["dateTime"] = dateTimeRequestBody

            // 4. Make the API call
            // If your interceptor handles the token, you might just call:
            // val response = apiService.startCheckIn(imagePart = imagePart)

            //val response = apiService.startCheckIn(authToken = authToken, imagePart = imagePart, partMap)
            val response = apiService.startCheckIn(
                authToken = authToken,
                imagePart = imagePart,
                latitude = 28.575447f,
                longitude = 77.44539f,
                dateTime = "Mon 8 Sep 2025 1:20 PM"
            )

            delay(2000) // Consider removing for production
            if (response.isSuccessful) {
                Log.e( // Consider Log.i for success
                    "FaceLivenessRepository",
                    "###@@@ Image Uploaded Successfully for CheckIn ${imageId}: ${response.message()}"
                )
                markImageAsUploaded(imageId)
            } else {
                Log.e(
                    "FaceLivenessRepository",
                    "###@@@ Failed to CheckIn image ${imageId}: Code: ${response.code()} Message: ${response.message()} ErrorBody: ${response.errorBody()?.string()}"
                )
            }
            Log.d("FaceLivenessRepository", "###@@@ CheckIn attempt for image ID: ${imageId}")

        } catch (e: Exception) {
            Log.e("FaceLivenessRepository", "###@@@ Error during CheckIn for image ${imageId}", e)
        }
        Log.d(
            "FaceLivenessRepository",
            "###@@@ startCheckIn: Processed." // More specific log
        )
    }

    // You might also need a function to delete images after successful upload or after a certain age
    suspend fun deleteUploadedImage(imageId: Long) {
        withContext(Dispatchers.IO) {
            try {
                faceImageDao.deleteImageById(imageId) // Assuming FaceImageDao has this method
                Log.d("FaceLivenessRepository", "Image with ID $imageId deleted from local DB.")
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error deleting image $imageId from local DB", e)
            }
        }
    }
}