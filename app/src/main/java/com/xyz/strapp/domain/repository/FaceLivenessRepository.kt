package com.xyz.strapp.domain.repository

import android.graphics.Bitmap
import android.util.Log
import com.xyz.strapp.data.dao.FaceImageDao
import com.xyz.strapp.domain.model.FaceImageEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import javax.inject.Inject
import javax.inject.Singleton

@Singleton // Repositories are often singletons managed by Hilt
class FaceLivenessRepository @Inject constructor(
    private val faceImageDao: FaceImageDao
    // TODO: Inject your Retrofit API service here when ready for network calls
    // private val faceApiService: YourFaceApiService
) {

    /**
     * Converts a Bitmap to ByteArray, creates a FaceImageEntity,
     * and inserts it into the Room database via the DAO.
     *
     * @param bitmap The bitmap of the live face to save.
     * @param timestamp The time the image was captured, defaults to current time.
     * @return The row ID of the newly inserted face image, or null on failure.
     */
    suspend fun saveFaceImage(bitmap: Bitmap, timestamp: Long = System.currentTimeMillis()): Long? {
        return withContext(Dispatchers.IO) { // Perform database and bitmap operations off the main thread
            try {
                val outputStream = ByteArrayOutputStream()
                bitmap.compress(
                    Bitmap.CompressFormat.JPEG,
                    90,
                    outputStream
                ) // Compress to JPEG, adjust quality as needed
                val imageByteArray = outputStream.toByteArray()

                if (imageByteArray.isEmpty()) {
                    Log.e("FaceLivenessRepository", "Converted ByteArray is empty.")
                    return@withContext null
                }

                val faceImageEntity = FaceImageEntity(
                    // id is typically auto-generated by Room, so 0 or null depending on your Entity
                    id = 0, // Or null if your primary key is nullable and auto-generated without default
                    imageData = imageByteArray,
                    timestamp = timestamp,
                    isUploaded = false // Initially, the image is not uploaded
                )

                val insertedId = faceImageDao.insertFaceImage(faceImageEntity)
                Log.d(
                    "FaceLivenessRepository",
                    "Face image saved with ID: $insertedId, Size: ${imageByteArray.size} bytes"
                )
                insertedId
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error saving face image", e)
                null // Return null or throw a custom domain exception
            }
        }
    }

    /**
     * Placeholder for fetching images that need to be uploaded.
     * This would typically fetch entities where isUploaded is false.
     */
    suspend fun getPendingUploads(): List<FaceImageEntity> {
        return withContext(Dispatchers.IO) {
            try {
                faceImageDao.getPendingUploads() // Assuming FaceImageDao has this method
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error fetching pending uploads", e)
                emptyList()
            }
        }
    }

    /**
     * Placeholder for marking an image as uploaded.
     * This would update the isUploaded flag in the database.
     *
     * @param imageId The ID of the image that has been successfully uploaded.
     */
    suspend fun markImageAsUploaded(imageId: Long) {
        withContext(Dispatchers.IO) {
            try {
                faceImageDao.markAsUploaded(imageId) // Assuming FaceImageDao has this method
                Log.d("FaceLivenessRepository", "Image with ID $imageId marked as uploaded.")
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error marking image $imageId as uploaded", e)
            }
        }
    }

    /**
     * TODO: Implement the actual server upload logic.
     * This function would:
     * 1. Get pending images using getPendingUploads().
     * 2. For each image:
     *    a. Attempt to upload it using a Retrofit service (e.g., faceApiService).
     *    b. If upload is successful, call markImageAsUploaded().
     *    c. Handle errors, retries, etc.
     * This should ideally be managed by WorkManager for robust background execution.
     */
    suspend fun uploadPendingImagesToServer() {
        // Example structure:
        // val pendingImages = getPendingUploads()
        // if (pendingImages.isEmpty()) {
        //     Log.d("FaceLivenessRepository", "No pending images to upload.")
        //     return
        // }
        //
        // for (imageEntity in pendingImages) {
        //     try {
        //         // val response = faceApiService.uploadImage(imageEntity.imageData) // Example
        //         // if (response.isSuccessful) {
        //         //    markImageAsUploaded(imageEntity.id)
        //         // } else {
        //         //    Log.e("FaceLivenessRepository", "Failed to upload image ${imageEntity.id}: ${response.message()}")
        //         // }
        //         Log.d("FaceLivenessRepository", "Simulating upload for image ID: ${imageEntity.id}")
        //         // Simulate success for now, actual implementation needed
        //         // markImageAsUploaded(imageEntity.id)
        //
        //     } catch (e: Exception) {
        //         Log.e("FaceLivenessRepository", "Error uploading image ${imageEntity.id}", e)
        //     }
        // }
        Log.d(
            "FaceLivenessRepository",
            "uploadPendingImagesToServer: Placeholder - implement actual upload logic."
        )
    }

    // You might also need a function to delete images after successful upload or after a certain age
    suspend fun deleteUploadedImage(imageId: Long) {
        withContext(Dispatchers.IO) {
            try {
                faceImageDao.deleteImageById(imageId) // Assuming FaceImageDao has this method
                Log.d("FaceLivenessRepository", "Image with ID $imageId deleted from local DB.")
            } catch (e: Exception) {
                Log.e("FaceLivenessRepository", "Error deleting image $imageId from local DB", e)
            }
        }
    }
}